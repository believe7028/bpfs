#!/usr/bin/env python
# Print a bpramcount log with function names in place of instruction pointers
# NOTE: addr2line only seems useful when bpfs is compiled with -O0

import subprocess
import sys
import os

bpfs = os.path.dirname(sys.argv[0]) + '/../bpfs'

ap = subprocess.Popen(['addr2line', '-f', '-e', bpfs],
					  stdin=subprocess.PIPE,
					  stdout=subprocess.PIPE)

in_backtraces = False

backtraces = []

for line in sys.stdin:
	line = line[:-1]
	if (not in_backtraces):
		if (line == 'write backtraces start:'):
			in_backtraces = True
		if (line.startswith('total number of bytes written: ')):
			sys.stdout.write('# ' + line + '\n');
		continue
	if (in_backtraces and line == 'write backtraces end'):
		in_backtraces = False
		break

	backtrace = []
	
	linelist = line.split()
	nbytes = linelist[0]
	ips = linelist[1:]

	backtrace.append(int(nbytes))

	for ip in ips:
		ap.stdin.write("%s\n" % ip)
		ap.stdin.flush()
		function = ap.stdout.readline()[:-1]
		fileline = ap.stdout.readline()[:-1].split(':')
		filename = fileline[0]
		lineno = fileline[1]
		backtrace.append("%s:%s" % (function, lineno))
	backtraces.append(backtrace)

def backtrace_sort(x, y):
	if (x[0] > y[0]):
		return 1
	elif x[0] == y[0]:
		return 0
	else:
		return -1

backtraces.sort(backtrace_sort)
backtraces.reverse()

for backtrace in backtraces:
	sys.stdout.write("%d" % backtrace[0])
	for elt in backtrace[1:]:
		sys.stdout.write(" %s" % elt)
	sys.stdout.write('\n')
