- could make truncate(expand) write fewer bytes by adding an inode field
	'valid', where valid <= nbytes
- introduce offset typedefs: blockno_t, pgno_t, byteno_t, nbytes_t, ?
	typedef uint64_t blkno_t;  // BPRAM block number
	typedef uint64_t blkidx_t; // block index into a file
	typedef uint64_t byteno_t; // byte number
- valgrind: http://valgrind.org/docs/manual/manual-core-adv.html

* benchmarks
- postmark
- untar
- rm
- something involving rename
- small, large appends, overwrites
- create large file
- well-respected benchmark

* measurements
- enable larger writes with (fuse 2.8 and -o big_writes) or -o direct_io?
- compare SCSP to SP. and minmal? and ext2,ext3,ext4,btrfs?
- bytes written
  - measure actual writes
    - what code contributes how much to this measurement?
    - valgrind? instrument code? (macros around writes? decls?)
	- must the controller write an entire cache line? if so, measure this?
  - measure #bytes that change in file system image
- number of epoch barriers?
- correctness
  - detect consistency
  - detect syscall atomicity
  - detect if file system does what it is supposed to (eg renames the file)

* limits
- SCSP write() can be atomic, but is it guaranteed? eg failed allocation part
  way through a large write? in general, how does abort work?

* long term notes
- code seems too complicated. maybe how to commit is tied too closely to other?
- when SCSP has to COW, would it ever be helpful to wait on committing the change for a later write that would have to re-COW a shared set of blocks?
	- SP mode would do this
- can SCSP work with one crawl down and then back up?
- could make truncate(expand) write fewer bytes by adding an inode field
	'valid', where valid <= nbytes

* near term notes
- convince self that current code is correct.
- fuse_rename() needs restructuring. probably needs crawl_inode_2().
- correctness test: snapshot ram before op, during op, and after: during should "match" before or after
	- want to snapshot during not during a machine instruction?
	- maybe track which bytes/pages change and only compare them for speed?
	- work with large file systems, too? (or, woozle has 8GB ram)
	- issue: syscalls are not "atomic". inode file grows in size, freed entries are modified, timestamp updates.
	- perhaps track in pin
- implement readdir() that works when called multiple times and contents change
- 64bit bpfs can create inos larger than 32b fuse can store. probably don't fix, just keep this in mind.
- fixme: commit_abort() does not abort entire syscall in SCSP
- do not allocate the first directory block when creating a directory?

* current work
- implement scsp
- add benchmarks and measurement tools

* on the horizon
- add more code documentation? (function definitions?) and/or clean up.
- make code fast in time, too, for ucsd?
